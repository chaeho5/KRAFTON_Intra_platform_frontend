# AI 활용 기록 (ai-notes.md)

본 프로젝트는 AI 페어 프로그래밍 파트너(Google Gemini)의 도움을 받아 개발되었습니다. 단순 복사/붙여넣기가 아닌, AI에게 요구사항을 제시하고 단계별로 코드를 생성받으며, 각 코드의 의미와 Vue/Pinia의 원리를 학습하고 검증하는 방식으로 진행했습니다.

## 1. 사용한 AI/도구

- Google Gemini

## 2. 주요 프롬프트 및 활용 방식 (핵심 5가지)

### 1) 첫 시작으로 페르소나 주입
- **주요 프롬프트 및 활용 방식**
    - "너는 이제부터 15년차 프론트엔드 개발자가 되어서 나의 과제 테스트를 도와줘. 과제 안내 보여줄게"(프롬프트)
    - 첫 시작에 위의 프롬프트 내용으로 페르소나를 부여하면서 시작하여 전문성을 갖추게 하였습니다.(give it a role 전략)

### 2) 과제 안내 내용 공유
-  **주요 프롬프트 및 활용 방식**
    - "과제 안내서 꼼꼼하게 읽고, Vue.js를 사용할거야, 나는 Vue.js가 처음이니까 잘 알려줘"(프롬프트)
    - 저의 Vue.js 경력을 공유하며 저의 수준에 맞게 안내할 수 있도록 하였습니다.
    - AI의 과제 공략 계획을 받고 빠르게 작업을 시작할 수 있었습니다.
    - 이 문서의 초안 또한 ai가 만들어주었습니다.


### 3) Pinia를 이용한 상태 관리 리팩토링 요청

- **활용 방식**:
    - `App.vue`에 집중되어 있던 모든 상태(state)와 로직(actions)을 Pinia 스토어로 이전하는 리팩토링을 요청했습니다.
- **AI의 기여**:
    - `src/stores/todoStore.js` 파일에 `defineStore`를 사용한 Pinia Setup Store의 전체 코드를 생성해 주었습니다.
    - `App.vue`가 스토어의 상태(`todos`)를 반응형으로 구독하는 방법(`storeToRefs`)을 알려주었습니다.
    - `TodoForm.vue`, `TodoItem.vue` 등 하위 컴포넌트가 `emit` 대신 스토어의 액션을 직접 호출(`todoStore.addNewTodo()`)하도록 수정하는 코드를 제공했습니다.
- **검증 및 수정**:
    - AI가 생성한 코드를 적용하며 `emit` 중계 로직이 사라지고 컴포넌트 구조가 단순해지는 것을 확인했습니다. `storeToRefs`의 필요성을 이해하고 적용했습니다.

### 4) Vitest 유닛 테스트 코드 생성 요청

- **활용 방식**:
    - "Pinia 스토어의 핵심 CRUD 로직에 대한 Vitest 테스트 코드를 작성해 줘."라고 요청했습니다.
- **AI의 기여**:
    - `describe`, `it`, `expect`를 사용한 테스트 스위트 전체 코드를 생성했습니다.
    - Pinia 테스트 시 상태 격리를 위한 `beforeEach`와 `setActivePinia(createPinia())` 사용법을 알려주었습니다.
- **검증 및 수정**:
    - 테스트 실행 시 `localStorage`로 인한 상태 오염으로 테스트가 실패하는 것을 발견했습니다.
    - AI에게 오류 로그를 보여주며 해결책을 요청했고, AI는 `beforeEach`에 `localStorage.clear()`를 추가하는 해결책을 제시했습니다. 이를 적용하여 모든 테스트가 통과하는 것을 확인했습니다.

### 5) 컴포넌트 내부 상태 및 조건부 렌더링 구현 (`TodoItem.vue` 수정)

- **활용 방식**:
    - "TODO 수정 기능을 위해 '조회 모드'와 '수정 모드'를 전환하는 로직을 구현해 줘."라고 요청했습니다.
- **AI의 기여**:
    - `TodoItem.vue` 내부에 `isEditing`이라는 로컬 `ref` 상태를 선언하는 방법을 알려주었습니다.
    - `v-if="!isEditing"`과 `v-else`를 사용해 '조회 UI'와 '수정 UI'를 조건부로 렌더링하는 `<template>` 코드를 생성했습니다.
    - '저장' 버튼 클릭 시 `emit`으로 수정된 데이터를 상위로 전달하는 `onSaveClick` 핸들러 로직을 작성해 주었습니다.
- **검증 및 수정**:
    - AI가 생성한 코드를 적용하고, `v-model`이 `editedTitle` 등 로컬 상태와 잘 바인딩되는지 확인했습니다. '취소' 버튼 클릭 시 다시 `props`의 값으로 초기화되는 로직의 중요성을 이해했습니다.

## 3. AI 생성 코드 반영 범위

- 프로젝트의 약 70%가 AI와의 페어 프로그래밍을 통해 생성되었습니다.
- Pinia 스토어 로직, Vitest 테스트 코드, Vue 컴포넌트(template, script, style)의 초기 뼈대 및 기능 구현 코드를 AI가 생성했습니다.

## 4. 직접 수정·검증한 내용 요약

- **AI가 제안한 잘못된 CSS 속성 수정**
    * **문제:** `TodoForm.vue`의 가로 정렬을 위해 AI가 `display: flex-between`이라는 **존재하지 않는 CSS 속성**을 제안했습니다.
    * **검증 및 수정:**
        * 이것이 `justify-content: space-between`의 오타임을 **파악**했습니다.
        * 요구사항에 맞게 `display: flex`와 `justify-content: flex-start`로 **직접 코드를 수정**하여 올바른 레이아웃을 완성했습니다.

- **코드의 로직 오류(Bug) 수정 (Watch 위치)**
    * **문제:** `TodoForm.vue`에서 오류 메시지를 지우는 `watch` 로직을 `handleSubmit` 함수 **안에** 생성했습니다.
    * **검증 및 수정:**
        * 이 코드는 폼 제출 시마다 `watch`가 중복 생성되는 **메모리 누수**를 일으키고, 정작 오류 발생 시엔 `watch`가 실행되지 않는 치명적 버그임을 **인지**했습니다.
        * `watch` 로직을 `handleSubmit` 함수 **밖**(`script setup`의 최상단)으로 **직접 이동**시켜, 컴포넌트 생성 시 단 한 번만 '감시자'가 등록되도록 수정하여 문제를 해결했습니다. 

- **누락한 코드(ESLint) 발견 및 수정**
    * **문제:** `TodoItem.vue`의 `onDeleteClick` 같은 함수 로직(`script`)을 만들었지만, 이를 호출하는 `@click` 핸들러(`template`)를 넣지 않아 '선언은 되었지만 해당 값이 읽히지는 않았습니다' 경고가 나왔습니다.
    * **검증 및 수정:**
        * VS Code의 ESLint가 띄우는 **'선언은 되었지만 해당 값이 읽히지는 않았습니다' 경고**를 **발견**했습니다.
        * `@click` 핸들러가 포함된 `<template>` 코드를 다시 만들었습니다.
